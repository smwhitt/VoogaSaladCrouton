/**
 * This class is responsible for displaying square cells to the user
 */
package voogasalad.view.authoringEnvironment.views.grid;

import javafx.geometry.Dimension2D;
import javafx.geometry.Point2D;
import javafx.scene.Group;
import javafx.scene.Node;
import javafx.scene.control.*;
import javafx.scene.image.ImageView;
import javafx.scene.layout.BorderPane;
import javafx.scene.layout.GridPane;
import javafx.scene.layout.Pane;
import javafx.scene.paint.Color;
import javafx.scene.shape.Rectangle;
import voogasalad.gameEngine.Engine;
import voogasalad.view.View;
import voogasalad.view.authoringEnvironment.controllers.grid.*;
import voogasalad.view.authoringEnvironment.data.WaveData;
import voogasalad.view.clickableobjects.ClickableButton;

import java.util.Map;
import java.util.ResourceBundle;

/**
 * @author Angel Huizar
 */
public class GridView extends View {
    protected double myRectangleWidth,myRectangleHeight;
    protected int myRows,myColumns;
    private GridData myData;
    protected Rectangle[][] myGrid;
    protected Group tileHolder;
    private String authoringTileStyle = "authoringTile";
    private String resourcePath = "voogasalad/view/authoringEnvironment/resources/";
    private String startStyle = System.getProperty("user.dir") + "/src/" + resourcePath + "images/" + "SpawnPoint1.png";
    private String endStyle = System.getProperty("user.dir") + "/src/" + resourcePath + "images/" + "EndPoint1.png";
    protected BorderPane myPane;
    protected Color myColor;
    private ResourceBundle myBundle, myLanguage;
    private String nameOfBundle = "Grid";
    private WaveData myWaveData;


    /**
     * This is the constructor which initializes the number of row and columns of the gird as well as the size of
     * each individual cell.
     * @param rows the number of rows in the grid
     * @param columns the number of columns in the grid
     * @param length the size of the display (in pixels)
     * @param engine the engine this class will be working with
     * @param waveData the waveData generated by the user so we can pass it to the view that is responsible for
     *                 associating a wave to a spawn point
     */
    public GridView(int rows, int columns, double length, Engine engine, WaveData waveData){
        super(length,length, Color.WHEAT, "Map Editor", engine);
        myPane = new BorderPane();
        myPane.setPrefSize(myWidth,myHeight);
        tileHolder = new Group();
        myData = new GridData(rows, columns, this::getYPosition,
                this::getXPosition,new Dimension2D(myRectangleWidth,myRectangleHeight), super.getEngine());
        myBundle = ResourceBundle.getBundle(resourcePath + nameOfBundle);
        setGridSize(rows,columns);
        myLanguage = ResourceBundle.getBundle(languagePath + LANGUAGE);
        myColor = Color.valueOf(myBundle.getString("defaultColor"));
        myWaveData = waveData;
    }

    /**
     * This constructor is used when you don't know how many rows and columns there are yet
     * @param length the size of the display (in pixels)
     * @param engine the engine this class will be working with
     */
    public GridView(double length, Engine engine){
        super(length,length, Color.WHEAT, "Map Editor", engine);
        myPane = new BorderPane();
        myPane.setPrefSize(myWidth,myHeight);
        tileHolder = new Group();
        myBundle = ResourceBundle.getBundle(resourcePath + nameOfBundle);
        myLanguage = ResourceBundle.getBundle(languagePath + LANGUAGE);
        myColor = Color.valueOf(myBundle.getString("defaultColor"));
    }

    /**
     * This method sets a particular tile to an image defined by the imagepath
     * @param imagePath the place where the image file is located
     * @param row the row of the tile
     * @param col the column of the tile
     * @param angle the angle of the picture
     */
    public void setTileImage(String imagePath, int row, int col, int angle, boolean calledFromPlayer){
        Point2D location = makeLocation(row,col);
        myData.setTileImage(imagePath,location,angle,tileHolder,calledFromPlayer);
    }

    /**
     * This method sets a particular tile to an image defined by the imagepath
     * @param imagePath the place where the image file is located
     * @param location the location of the tile in terms of pixels (x then y)
     * @param angle the angle of the picture
     */
    public void setTileImage(String imagePath, Point2D location, int angle, boolean calledFromPlayer){
        myData.setTileImage(imagePath,location,angle,tileHolder,calledFromPlayer);
    }

    /**
     * This method sets a particular tile to an image
     * @param imagePath the file path of the image
     * @param location the location of the tile (in pixels)
     */
    public void setTileImage(String imagePath, Point2D location){
        myData.setTileImage(imagePath,location,tileHolder);
    }

    /**
     * This method resets the size of the grid
     * @param rows the new number of rows
     * @param columns the new number of columns
     */
    public void setGridSize(int rows, int columns){
        myRows = rows;
        myColumns = columns;
        myGrid = new Rectangle[myRows][myColumns];
        tileHolder.getChildren().clear();
        setUpWidth();
        setUpHeight();
        if(myData == null){
            myData = new GridData(rows, columns, this::getYPosition,
                    this::getXPosition,new Dimension2D(myRectangleWidth,myRectangleHeight), super.getEngine());
        }
        else {
            myData.setGridSize(rows, columns, new Dimension2D(myRectangleWidth, myRectangleHeight));
        }
    }

    @Override
    public Node startVisualization() {
        myPane.setLeft(setUpGrid());
        myPane.setRight(createGridOptions());
        return myPane;
    }

    /**
     * This method removes an image from a tile
     * @param row the row of the tile
     * @param col the column of the tile
     */
    public void removeTileImage(int row, int col) {
        myGrid[row][col].setId(authoringTileStyle);
        myData.removeTileImage(makeLocation(row,col),tileHolder);
    }

    /**
     * This method sets the color of the grid
     * @param color the new color of the grid
     */
    public void setGridColor(Color color){
        myColor = color;
        tileHolder.getChildren().stream()
                .filter(n->n.getClass()!=ImageView.class)
                .forEach(n->((Rectangle)n).setFill(color));
    }

    /**
     * This method clears all tiles of any images and clears the model of any previous knowledge of those tiles then
     * displays the newly cleaned board
     */
    public void resetGrid(){
        setGridSize(myRows,myColumns);
        myPane.setLeft(setUpGrid());
    }

    /**
     * This method gets the same instance of grid data that the view uses to help manage grid data
     * @return grid data that the view is working with
     */
    public GridData getMyData(){
        return myData;
    }

    /**
     * This method lets other classes transform rows and columns into a point containing the x and y coordinates of
     * the given row and column
     * @param row the row a tile is in
     * @param col the column the tile is in
     * @return a point2D that contains the x and y location of the tile in pixels
     */
    public Point2D makeLocation(int row, int col){
        double c = getXPosition(col);
        double r = getYPosition(row);
        return new Point2D(c,r);
    }

    private Node createGridOptions() {
        GridPane pane = new GridPane();
        ColorPicker picker = new ColorPicker();
        picker.setOnAction(event -> {
            new ChangeGridColor(this,picker.getValue(),super.getEngine()).execute();
        });
        pane.add(picker,0,0);
        Label label = new Label(String.format(myLanguage.getString("sizeLabel"),Double.parseDouble(myBundle.getString("defaultSize"))));
        Slider slider = new Slider(Double.parseDouble(myBundle.getString("minSize")), Double.parseDouble(myBundle.getString("maxSize")),Double.parseDouble(myBundle.getString("defaultSize")));
        slider.valueProperty().addListener((observable, oldValue, newValue) -> {
            label.setText(String.format(myLanguage.getString("sizeLabel"),newValue.doubleValue()));
            setGridSize(newValue.intValue(),newValue.intValue());
            myPane.setLeft(setUpGrid());
        });
        pane.add(label,0,1);
        pane.add(slider,1,1);
        Label label1 = new Label(myLanguage.getString("namePrompt"));
        TextField textField = new TextField(String.format(myLanguage.getString("defaultMapName"),myData.getMapNames().size()));
        pane.add(label1,0,2);
        pane.add(textField,1,2);
        ChoiceBox<String> maps = new ChoiceBox<String>(myData.getMapNames());
        maps.setOnAction(event -> {
            if(maps.getValue()!=null) {
                textField.setText(maps.getValue());
                loadGrid(myData.getGridStateFromName(maps.getValue()), slider);
            }
        });
        //Create button to save map
        ClickableButton button = new ClickableButton(myLanguage.getString("saveMap"),new SaveGridState(myData,textField,maps,super.getEngine()));
        pane.add(button.getNode(),0,3);
        //Create button to delete map
        ClickableButton button1 = new ClickableButton(myLanguage.getString("deleteMap"), new DeleteGridState(myData,maps,this,super.getEngine()));
        pane.add(button1.getNode(),0,4);
        pane.add(maps,1,3);

        //create instructions for user
        Label instructions = new Label(myLanguage.getString("mapInstructions"));
        pane.add(instructions,1,4);
        return pane;
    }

    private Node setUpGrid() {
        DragPathCreator creator = new DragPathCreator(this,super.getEngine());
        SetStartNEndPoints tileClick = new SetStartNEndPoints(myData,this, super.getEngine(), myWaveData);
        for(int r = 0; r < myRows; r++){
            for(int c = 0; c < myColumns; c++){
                createRectangle(creator, tileClick, r, c);
            }
        }
        return tileHolder;
    }

    private void setUpWidth(){
        myRectangleWidth = myWidth / (myColumns);
    }

    private void setUpHeight(){
        myRectangleHeight = myHeight / (myRows);
    }

    protected double getXPosition(int c){
        return (c * myRectangleWidth);
    }

    protected double getYPosition(int r){
        return ((myHeight - (myRectangleHeight)) - (r * myRectangleHeight));
    }

    /**
     * This method lets you know if a tile has an image in it
     * @param row the row of the tile
     * @param column the column of the tile
     * @return true if the tile has an image in it, false otherwise
     */
    public boolean containsTileImage(int row, int column){
        return myData.containsTileImage(makeLocation(row,column));
    }

    private void loadGrid(Map<Point2D, Map<String, String>> gridState, Slider sliderToChange) {
        int sizeSquared = gridState.keySet().size();
        int size = (int) Math.sqrt(sizeSquared);
        sliderToChange.setValue(size);
        setGridSize(size,size);
        myPane.setLeft(setUpGrid(gridState));
    }

    private Node setUpGrid(Map<Point2D, Map<String, String>> gridState) {
        DragPathCreator creator = new DragPathCreator(this,super.getEngine());
        SetStartNEndPoints tileClick = new SetStartNEndPoints(myData,this, this.getEngine(), myWaveData);
        for (int r = 0; r < myRows; r++){
            for (int c = 0; c < myColumns; c++){
                createRectangle(creator, tileClick, r, c);
                if (!gridState.get(makeLocation(r,c)).get("image").equals("null")){
                    setTileImage(gridState.get(makeLocation(r,c)).get("image"),r,c,Integer.parseInt(gridState.get(makeLocation(r,c)).get("angle")),false);
                }
                if(gridState.get(makeLocation(r,c)).get("path").equals("start")){
                    myData.setStart(makeLocation(r,c));
                }
                else if (gridState.get(makeLocation(r,c)).get("path").equals("end")){
                    myData.setEnd(makeLocation(r,c));
                }

            }
        }
        return tileHolder;
    }

    private void createRectangle(DragPathCreator creator, SetStartNEndPoints tileClick, int r, int c) {
        myGrid[r][c] = new Rectangle(getXPosition(c),getYPosition(r),myRectangleWidth, myRectangleHeight);
        myGrid[r][c].setId(authoringTileStyle);
        creator.addNode(r,c,myGrid[r][c]);
        tileClick.addNode(myGrid[r][c],makeLocation(r,c),startStyle,endStyle);
        myGrid[r][c].setFill(myColor);
        tileHolder.getChildren().add(myGrid[r][c]);
    }

    /**
     * This method returns the pane this display is using
     * @return the borderPane this class is using to display information
     */
    public Node getPane() {
        return myPane;
    }

}
