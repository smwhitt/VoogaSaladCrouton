# Use Cases 
1. Allow author to create a path by clicking on screen - when author clicks on a location on the canvas, and the author then clicks on a path tile for a certain direction/shape of path, that path piece is added to the clicked location on the canvas
2. Allow author to place a defense - when author clicks on a location on the map, and the author clicks on defense, the defense is placed on that location. 
3. Allow author to assign a path to a defense or enemy - when the author clicks on a defense or enemy on the map, as well as on a path that defense or enemy is adjacent to, a behavior parameter can be edited in the behavior tab of the authoring environment to assign that path to that defense or enemy, so that defense or enemy knows to travel down that path
4. Allow author to edit defense parameters - With the defense at a particular location still selected, the author uses the behavior tab on the side of the authoring environment customize what that defense does (active/passive, range, does it shoot or attack, etc). The defense on the map now, when the player is run, behaves according to the rules set by the author in the authoring environment
5. Allow author to upload custom images for game - when the author selects a defense on the map, the appearance tab in the authoring environment can be used to set an image for that defense. When the set image button on this tab is clicked, a window pops up to allow the author to explore files and select an image. Once an image is selected, this image replaces the generic defense image displayed at the clicked location on the map
6. Allow author to set tower location - when the author clicks a location on the map, and the author clicks on a tower, a tower is placed at that map location
7. set metadata and config options about the game/game environment, like title, author name, as well as possible settings for the environment program itself. - the author can enter this information into a textfield and hit a save game button, which will write this information into the appropriate location in the game data file
8. Allow author to set enemy location - when author clicks on a map location and clicks on an enemy, that location now displays an enemy
9. Allow author to set enemy behavior parameters - when author clicks on an enemy component on the map, they can then go to the behavior tab and click on different behaviors to apply them to the enemy (what is the range of enemy attacks, how fast do they move, etc)
10. Allow author to select enemy image - when author clicks on a generic enemy placed on a map, and then goes to the appearance tab in the authoring environment, they can click an add image button, which opens a file explorer, for the correct image to be added to replace the generic enemy, which is then displayed on the map in the correct location
11. Allow author to select checkbox allowing defenses to be placed on top of paths - if this is selected, then defenses can be placed on top of paths, i.e. paths the enemies traverse, during gameplay (when the game is being run/tested in the player)
12. Allow author to set resources dropped by enemy when killed (on an action of the enemy in general) - after an enemy is added to the map, the author can click on it and go to the behavior tab, where the behavior of having a resource to be given to the player once the enemy's health has been reduced to 0 (enemy has been killed) by a game player, can be added. When the player is launched and an enemy is killed by the user, resource counts in the player's stats are augumented
13. Allow author to set background color - when the author clicks on a general map tab, and then clicks on a color picker labeled "set background color", the background color for the map is set
14. Allow author to select bullet (dart) images for instances where the defense shoots projectiles
* Like bullet speed, the image associated with an object is another parameter to be provided to the object during its definition in the authoring environment. For images, the user will be provided with the choice to attach an image to a projectile. When this is sent to the backend for validation and creation, the backend will recieve the file name and check whether the file path is valid before saving.
15. Allow author to select bullet speed (and other parameters)
* Since bullets are features of defenses, the user will select a defense and get the opportunity to define properties of its projectiles, alongside the properties of the defenses. The projectile speed will get entered by the user in a textbox, and once all parameters are defined, the parameters of the entire defense object are provided to the engine to be created, validated, and saved.
16. Allow author to select select bullet effects (damage over time, or slowing down enemies)
* When selecting a defense (which launches bullets), the user gets to define the defense properties generally, one of which is the type of bullets a relevant defense generates. Beyond firing speed and bullet speed, properties like any effects the bullets may have would be defined as parameters of defense from which they are generated. Once these parameters are decided by the designer, the defense object would get saved using a call to engine.create(), and the object then lives in the backend and can then be saved as necessary.
17. Allow author to set tower properties (i.e. health)
* The user selects a tower object from the authoring environment display and places it somewhere on the board. The user selects the tower and accesses the available properties for modification (as read from a tower.properties file). The player modifies the properties available, and upon setting the value, a call gets made to engine to create the tower object with the set parameters in the backend, and then from there validated and saved to the data file.
18. Allow player to upgrade defenses to increase damage
* To the user, when they click on a defense, they will get to upgrade the defense if their resources match the corresponding level. Internally, the clicking interaction will lead to a bound defense object recieving a call to update, which changes internal parameters of the engine object and thus the values made apparent on the front end (like health, image, projectile features or qualities).
19. Allow author to dictate waves (order of advancement) - levels should be tabbed out in the authoring environment, so when the author opens a new tab, this tab allows for the editing of a new level of the game, essentially opening a new authoring environment in this tab with a clean map but the same capabilities as the authoring environment open in the previous tab
20. delete a minion type from the authoring environment
21. Allow author to save game - when the developer clicks the save button on the authoring environment, the game created in the canvas by the developer is saved into a data file that can be loaded into the game engine to be run on the player
22. delete a map configuration from the editor, and either remove the map from any levels that use it, or require that references to the map be removed before the map itself can be deleted.
23. remove a level or minion wave from a level
24. Allow player to load game - when a button is clicked in the authoring environment that says "play game", the game engine reads in the game file, and a window pops up that allows the developer to play the game
25. Keep track of high score - when a player wants to know what his/her high score has been, the player can look at the headsup display in testing player. This means that every time a player plays the game, their score is recorded into the game data file, so their highest score can be found to be displayed
26. Allow author to place headsup display - the author clicks on a location on the map, and then clicks on a data display box from under some sort of "general components" tab. The data display box is now displayed at that location. It shows the score of the player, as well as other stats of the player, i.e. the player's resource counts.
27. Provide a way for the player to continue playing after a loss - When a player loses a level, a replay button pops up on a splash screen in the player. Clicking the replay button should reset the state of the level to its initial state, with defenses, enemies, and tower all in their initial locations
28. Provide a home screen to hold the load game and continue playing functionality (Player) - once the player is launched, a splash screen is the first thing to pop up, with a "play game" button. Once a user clicks this button, the gameplay begins from the first level, and there exists a home button on the gameplay screen allowing the user to return to the home screen at any time. This button is present on all levels, as well as on the restart splash screen 
29. Set the dart and enemy to "dead" when the two collide
* The user opens the authoring environment. After selecting the dart and enemy as objects within the game, the user can select the dart and view its properties. In the properties view, there will be check boxes for the user to select including one that "kills" the dart when collision with enemy. The user checks that and the property is written for the dart object to XML according to the appropriate modifiable parameters outlined by the engine. The above process is repeated for a enemy in the authoring environment.
30. Set the enemy to lose 10 health when colliding with dart.
* The user opens the authoring environment. After selecting the dart and enemy as objects within the game, the user can select the enemy and view its properties. In the properties view, there will be check boxes for the user to select including one that "damages" the enemy. One the box is checked, the user can specify in an entry field the number of "health" damage the enemy takes, in this case 10. From there, the checked property and the amount of health are written to XML so that the engine can use it later in the game player.
31. Enable programmer to add new type of projectile to engine
* In the engine package, there will be small inheritance hierarchies that represent object that are in the game. Locate the projectile hierachy and extend the superclass to implement custom projectile. Afterwards, ensure that the class implements the Entity interface so that the engine can keep track of all entities. If there are attributes that the projectile needs in the form of declared classes (ie. animated), add that as a module to the custom projectile class.
32. Allow player to gain resources when a bloon is destroyed
* In the authoring environment, select a bloon that is active in the game. Once selected, in the properties locate collisions with a dart. Check the box "change resources" and in the entry field, write the amount of resources to add. From there, the checked property and the amount of resources are written to XML so that the engine can use it later in the game player.
33. Set the victory condition for a level as destroying all bloons
* In the authoring environment, locate the window for "Victory Conditions". There will be an option to set a level's victory condition and from a list of check boxes, one will be "Advance when all enemies defeated". Check this box. This information will be written to XML and later used as data in the game player for the engine to input and run.
34. Allow the user to use additional defenses available after the user has obtained the currency to place the defense - when the author adds defenses for the user to see, they are added on click to a toolbar in the side of the map that the user can click to use in the player. Once added, the author can click on a defense to change its behavior in the behavior tab of the authoring environment and set a resource requirement for the defense to be used by the user. This means that if a user has insufficient resources to utilize a certain defense, an error message pops up reminding them of that
35. Allow the author to spawn multiple enemies from a starting location in a continuous flow - when an author places an enemy at a location, the authoring environment does not prevent the author from clicking on this location again and then clicking on a generic enemy component (displayed in a general components toolbar in the authoring environment) to add another enemy at the same location.
37. Display "Game Over" when the total number of lives left is less than 1 - when a user has lost all their health and/or lives, the player displays a game over message on a splash screen that also contains a restart button and a home button to allow the user to return home
38. Allow the user to load the state of the game - when an author clicks a button in the authoring environment to launch a player, a window pops up asking them to select the file with the appropriate game data. Once this is selected, the file is read into the game engine, and the player is launched
39. Allow the user to pull a previously created game and continue editing it - load editable game button exists in the authoring environment, and game files can be loaded into the authoring environment 
40. Allow a user to save their progress in a game - when a user presses the save button in the player, the user's stats and the new locations of game components are saved into the game data file, so the next time the data file is read into the game engine upon launch of the player, the user can start where they left off in the game
41. Allow the author to manipulate a game by directly editing the XML file - the author can open up game data files by clicking on a "view game data file" button that opens the xml file in a text file to be edited by the author, and then saved, with the changes displaying in the authoring environment's game maps upon reloading of the data
42. Allow the author to checkbox 'AI' to set the movement of an active "minion" defense - Once the author clicks on a defense object that is active in behavior and moves, opening the behavior tab will allow the author to click a checkbox called "AI" that when checked, will determine the movement of the active minion defense (i.e. deploying soldiers to defend against enemies) through artificial intelligence
43. Allow the user to choose spawning location of an active "minion" defense - the user in the player can click a location on the game map for the level and click the minion defense to set the "spawn point" of this defense. Once this is set, the defending minions will immediately originate from that location and move in programmed directions to attack the enemies 
44. Customize the intelligence / behavior of an active "minion" defense--that is, set its AI behavior. - Clicking the AI label next to the checkbox will open controls to the author of the environment that have buttons for different AI options. Clicking one of these buttons will set the AI of the defending minions to the corresponding AI denoted by the button. The minions, when spawned, will move according to that AI
45. delete an author-created template for a game component (enemy, defense, tower, etc) - clicking a game component placed on the map and then pressing the delete key on the keyboard will remove the game component from the map in the authoring environment, along with all the properties of appearance and behavior associated with that component.
